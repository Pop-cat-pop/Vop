= Отчет по лабораторной работе №7

Анисимова А.М.    <КЭ-413>

:description: Лабораторная работа №7
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:sectnums: |,all|
:imagesdir: Lab7Image


Целью 7 работы является изменение функции delay(). 

== Старая версия функции delay()


Изначальный вид функции delay() в старых версиях программы. 

[source, cpp]
----
void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)
  {
  // asm volatile("");
  }
}
----

Эта программа работает на настроенных частотах микропроцессора. Мы не управляем напрямую задержкой и не можем её изменять в коде программы.


== Функция delay() с тактированием от STK

Рассмотрим новый вид функции delay(). 

[source, cpp]
----
std::uint32_t SystemCoreClock = 13'333'000U;

void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
    // 1. Посчитать значение задержки
  const auto timerDelayCounts = (SystemCoreClock / 1000U) * timeInMs;
    // 2. Записать в регистре LOAD значение задержки
  STK::LOAD::Write(timerDelayCounts - 1);
    // 3. Сброс текущего значения таймера
  STK::VAL::Write(0);

    //4. Включить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Enable::Set();
    //5. Ожидание окончания задержки
  while(STK::CTRL::COUNTFLAG::NoOverflow::IsSet())
  {
  }

    // 6. Отключить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Disable();
}
----

Этот код реализует функцию задержки на основе системного таймера (SysTick) микроконтроллера STM32F411xC/E. SysTick (STK) — это встроенный 24-разрядный таймер, который работает с тактовой частотой процессора (SystemCoreClock).

.   Вычисление количества тактов для задержки. SystemCoreClock - переменная хранит текущую частоту тактирования ядра (в герцах). Деление частоты на 1000 переводит такты из секунд в миллисекунды. timerDelayCounts - общее количество тактов, которые SysTick должен отсчитать для задержки в timeInMs.

.   Установка регистра LOAD. LOAD - регистр загрузки, который определяет максимальное значение отсчета для SysTick. Таймер будет считать от этого значения до 0. (timerDelayCounts - 1) - устанавка в регистр значения, соответствующее длительности задержки. Вычитаем 1, так как счетчик SysTick считает до 0.

.   Сброс текущего значения таймера. VAL - текущий регистр счетчика SysTick. Установка его в 0 обнуляет таймер, чтобы начать отсчет с полной задержки.

.   Включение SysTick. CTRL - регистр управления SysTick. ENABLE  включает таймер SysTick. С этого момента таймер начинает считать от значения в регистре LOAD до 0.

.   Ожидание окончания задержки. COUNTFLAG - флаг выставляется в 1, когда таймер досчитал до 0. Пока цикл таймера не досчитает до 0, функция находится в ожидании.

.   Выключение SysTick. Отключение таймера - после завершения задержки таймер выключается.



== Функция delay() с тактированием от TIM5

=== Таймеры общего назначения TIM2 и TIM5

Разберём информации о двух таймерах. 

Таймеры общего назначения представляют собой 16- или 32-битные счетчики с автоматической перезагрузкой, управляемые программируемым предделителем.
Они могут использоваться для различных целей, включая измерение длительности импульсов входных сигналов (захват входа) или генерацию выходных сигналов (сравнение выходного сигнала и ШИМ).

Длительность импульсов и периоды сигналов могут изменяться от нескольких микросекунд до нескольких миллисекунд с использованием предделителя таймера и предделителей контроллера тактирования RCC.

Таймеры полностью независимы и не используют общие ресурсы. Тем не менее, они могут быть синхронизированы между собой.

=== Характеристики TIM2 и TIM5

Функциональные возможности таймеров общего назначения TIMx включают:

*   16-битный (TIM3 и TIM4) или 32-битный (TIM2 и TIM5) счетчик с автоматической перезагрузкой, работающий в режимах увеличения, уменьшения или увеличения/уменьшения.
*   16-битный программируемый предделитель, который может делить частоту тактового сигнала счетчика на любой коэффициент от 1 до 65536 (в том числе в процессе работы).
*   До 4 независимых каналов для:
**  Захвата входного сигнала (Input Capture).
**  Сравнения выходного сигнала (Output Compare).
**  Генерации ШИМ (в режимах выравнивания по фронту или по центру).
**  Выхода в режиме одиночного импульса (One-Pulse Mode).
*   Схема синхронизации для управления таймером внешними сигналами и взаимосвязывания нескольких таймеров.
*   Генерация прерываний/DMA по следующим событиям:
**  Обновление: переполнение/недополнение счетчика, инициализация счетчика (программно или с использованием внутреннего/внешнего триггера).
**  Событие триггера (запуск, остановка, инициализация или подсчет по внутреннему/внешнему триггеру).
**  Захват входного сигнала.
**  Сравнение выходного сигнала.
*   Поддержка инкрементальных (квадратурных) энкодеров и датчиков Холла для задач позиционирования.
*   Вход триггера для внешнего тактирования или управления током на каждом цикле.


.Блок-схема таймеров TIM2 и TIM5
image::Lab7_1.png[]

=== Регистры TIM2

Регистр опций TIM2 (TIM2_OR)

*   Смещение адреса: 0x50
*   Значение после сброса: 0x0000

.Регистр опций TIM2 (TIM2_OR)
image::Lab7_4.png[]

Биты 15:12 — Зарезервированы, должны оставаться в значении по умолчанию (значение сброса).

Биты 11:10 — ITR1_RMP: Переназначение внутреннего триггера 1

*   Устанавливаются и сбрасываются программно.
*   Возможные значения:
**  00: Зарезервировано.
**  01: Выход триггера PTP подключен к TIM2_ITR1.
**  10: Выход SOF (Start of Frame) USB OTG FS подключен ко входу TIM2_ITR1.
**  11: Выход SOF USB OTG HS подключен ко входу TIM2_ITR1.

Биты 9:0 — Зарезервированы, должны оставаться в значении по умолчанию (значение сброса).



.Карта резисторов таймеров TIM2 и TIM5 часть 1
image::Lab7_2.png[]

.Карта резисторов таймеров TIM2 и TIM5 часть 2
image::Lab7_3.png[]


=== Результирующая функция delay на основе TIM2

[source, cpp]
----
void delay(std::uint32_t timeInMs)
{
    1. Проверка входного параметра
  assert(timeInMs < 10000);
    2. Посчитать значение задержки
  const auto prescalerValue = SystemCoreClock / 1000U;
  
    3. Настройка предделителя
  TIM2::PSC::Write(prescalerValue - 1U);
    4. Настройка режима таймера
  TIM2::CR1::URS::Value1::Set();
    5. Настройка значения автоперезагрузки
  TIM2::ARR::Write(timeInMs);
    6. Сброс флага обновления
  TIM2::SR::UIF::Set(0);
    7. Сброс текущего значения счетчика
  TIM2::CNT::Write(0);
    8. Запуск таймера
  TIM2::CR1::CEN::Enable::Set();
    9. Ожидание завершения задержки
  while(TIM2::SR::UIF::NoInterruptPending::IsSet())
  {
  }
    10. Остановка таймера
  TIM2::CR1::CEN::Disable::Set();
}
----

. Проверка входного параметра. Функция проверяет, что значение задержки (timeInMs) меньше 10 000 миллисекунд. Это ограничение связано с возможностями таймера и предотвращением чрезмерно долгих задержек.

. Посчитать значение задержки. SystemCoreClock - частота тактирования ядра (в герцах). Деление частоты на 1000 переводит значение в такты на миллисекунду. prescalerValue - значение используется для настройки предделителя таймера, чтобы он считал с частотой 1 кГц (то есть 1 такт равен 1 миллисекунде).

. Настройка предделителя. PSC (Prescaler Register) - регистр предделителя таймера. Умножив базовую частоту таймера на делитель, мы получаем новую тактовую частоту для счетчика. (prescalerValue - 1)- устанавливает предделитель, чтобы таймер считал с частотой 1 кГц.

. Настройка режима таймера. URS (Update Request Source) - бит настраивает таймер так, чтобы прерывания (или флаг обновления) генерировались только по событию переполнения счетчика, а не при других событиях.

. Настройка значения автоперезагрузки. ARR (Auto-Reload Register) - регистр определяет, до какого значения будет считать таймер перед сбросом (переполнением). Здесь устанавливается значение timeInMs, чтобы таймер считал ровно столько миллисекунд, сколько указано.


. Сброс флага обновления. UIF (Update Interrupt Flag) - флаг, который устанавливается, когда таймер достигает значения переполнения. Его сброс гарантирует, что задержка начнется с чистого состояния.


. Сброс текущего значения счетчика. CNT (Counter Register) - регистр содержит текущее значение счетчика таймера. Обнуляем его, чтобы таймер начал отсчет с 0.


. Запуск таймера. CEN (Counter Enable) - включение таймера. С этого момента таймер начинает отсчет от 0 до значения ARR.

. Ожидание завершения задержки. UIF::NoInterruptPending - флаг, показывающий, что таймер еще не достиг значения переполнения (обновления). Цикл ожидания завершает выполнение только тогда, когда таймер досчитает до заданного значения (ARR).

. Остановка таймера. Отключение таймера после завершения задержки.

== Вывод 

В ходе работы были разобраны три реализации задержки, которые использовали в реализации нашего проекта. 


