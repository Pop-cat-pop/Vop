= Отчет по лабораторной работе №2

:autor:                 А.М. Анисимова 
:numGroup:              КЭ-413
:numLab:                2
:checker:               С.В. Колодий
:year:                  2024

:toc:
:imagesdir:             Images
:toc-title:             Оглавление
:figure-caption:        Рисунок
:table-caption:         Таблица
:sectnums:              |,all|

[attributes]
====
include::Titl.adoc[]
====

== Типы данных

[.notes]
--
Одно из главных правил портируемости состоит в том, что для разных ядер микроконтроллеров один и тот
же тип переменной имел одинаковый размер. Для этого давайте разберемся, что такое тип и почему он
может иметь разную длину?
Для нашего микроконтроллера компилятор поддерживает следующие типы, см <<Встроенные типа С++>>.
--
[#Типы данных в С++]
.Типы данных в С++
image::Lab2_1.png[800, 1280]

== Встроенные типы

[#Встроенные типы С++]
.Встроенные типы С++
[options="header"]
[cols="2,1,7"]
|=====================
|Тип | Длина |Комментарий
|*bool*| 1| Представляет значения, которые могут быть или *true*, или *false*.
|*char*|1	| Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.
|*unsigned char*| 1 |	Аналог байта. В С++17 стандарте появился тип std::byte
|*int*|	4 |Целочисленное значение. Выбор по умолчанию для целых чисел
|*unsigned int*| 4| Беззнаковое целое число
|*float*| 4	|Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами
|*double*| 8	|Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой
|=====================

== Модификаторы типов данных

[#Встроенные типы С++ модификаторы]
.Встроенные типа С++ модификаторы
[options="header"]
[cols="2,1, 7"]
|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

== Размеры типов данных
Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров
типов существует правило:
[.source, cpp]
----
1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
std::uint32_t:: целое беззнаковое длиной 32 бита
std::int64_t::  целое знаковое длинной 64 бита
std::uint8_t:: целое знаковое длинной 8 бит

== Псевдонимы типов

Для того, чтобы было было понятнее работать с типом можно вводить их псевдонимы (alias). С помощью
ключевого слова *using* ;

[.source, cpp]
----
using ulong = unsigned long;

int main() {
    ulong largeNumber = 1000000;
    return 0;
}
----

== Преобразование типов

=== Неявное преобразование типов (implicit conversion)

Неявное преобразование происходит автоматически компилятором, когда требуется преобразовать один тип данных в другой.
[.source, cpp]
----
int main() {
    int a = 10;
    double b = 5.5;

    // Неявное преобразование int к double
    double result = a + b; // a неявно преобразуется в double

    return 0;
}
----

=== Явное преобразование типов (explicit conversion)

Явное преобразование требует от программиста указания, как именно нужно преобразовать один тип в другой. Это может быть сделано с помощью приведения типа (type casting).
[.source, cpp]
----
int main() {
    double pi = 3.14159;
    
    // Явное приведение к int (C-style cast)
    int intPi = (int)pi; // intPi = 3
    
    return 0;
}
----

== Память микркоконтроллера

ARM имеет общее адресное пространство для данных и команд.

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF.

Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную
память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в
которую можно писать (ОЗУ).

Также часть адресов этой памяти отведены под регистры управления и регистры периферии.

.Карта памяти микропроцессора
image::Lab2_2.png[]

[.notes]
--
Микроконтроллер  на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на
три типа:

* ПЗУ  (FLASH память в которой храниться программа);
* ОЗУ память для хранения временных данных (туда же можно по необходимости переместить программу и
  выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с
  периферией;
* Память для хранения постоянных данных ЕЕPROM.
--


Распеределение адрессов:

. Адресное пространство памяти программы постоянное запоминающее устройство (ПЗУ) находится по адресам *0x00000000* по *0x1FFFFFFF*;

. Адресное пространство оперативное запоминающее устройство (ОЗУ) находится по адресам  *0x20000000* по *0x3FFFFFFF*;

. Адресное пространство для регистров периферии находится по адресам с *0x40000000*  по *0x5FFFFFFF*;

. Памяти EEPROM микропроцессора Stm32F411RE не содержит.



=== Расспределение памяти ОЗУ

Данные в памяти могут быть расположены 3 различными способами:

* Авто(локальные) переменные, которые являются локальными в функции располагаются в регистрах или в стеке.

[.notes]
--
Такие переменные "существуют" только внутри функции, как только функция закончится и вернется к вызывающему
объекту, эти переменные становятся не валидными.
--
* Глобальные переменные или статические переменные. В этом случае они инициализируются единожды.

[.notes]
--
Static означает, что та память, которая была выделена под эту переменную не будет изменяться и
закрепляется за этой переменной до конца работы приложения.
--
* Динамически размещаемые данные. Данные создаваемые на Куче(Heap)

[.notes]
--
Если заранее не известно, сколько объектов нужно создать, и сколько памяти они будут отнимать, то придется
создавать их динамически, например с помощью оператора new, в таком случае, объекты будут создаваться в куче.
--

=== Память под функции(команды)

Для расположения функций используется та же самая память с границами от *0x00000000 - 0xFFFFFFFF*.

По умолчанию весь код будет лежать в сегменте .text, который расположен в readonly памяти (обычно в ROM),
но можно разместить функции и в ОЗУ.

== Указатель

[.notes]
--
Как мы уже поняли, данные могут находится в ОЗУ или ПЗУ. Каждой переменной содержащей данные соответствует
некий адрес памяти. К переменной можно обратиться непосредственно обращаясь к самой переменной, тогда мы
можем напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель
или ссылку.
--
Указатель это переменная, которая хранит адрес какой-то другой переменной:

[source, cpp]
----
int main() {
  int  c = 463 ;   # <1>
  int* ptr = &c ;  # <2>
  return 0;
}
----
[.notes]
--
<1> Объявляем переменную *c* типа *int*
<2> объявляем указатель *ptr* на переменную *c* типа *int*
--

[#Указатель]
.Указатель
image::Lab2_3.png[]

Размер указателя для нашего микроконтроллера 4 байта (32 бита).

=== Взятие адреса и разыменование указателя.

[source,cpp]

----
int main() {
  int  c = 463 ;              # <1>
  int* ptr = &c ;             # <2>
  cout << &c ;                # <3>
  cout << c ;                 # <4>

  *ptr = 5;                   #<5>
  cout << c << ": " << *ptr;  # <6>
}
----
<1> Объявление переменной
<2> Оператор & - оператор взятия адреса.
<3> Выведется адрес переменной *с* (0х100)
<4> Выведется значение переменной с (463)
<5> Операция разыменование указателя, записываем в переменную по адресу, который лежит в ptr, число 5
<6> Вывод значения переменной с и значения лежащего по адресу, на который указывает указатель (5: 5)
По сути с и *ptr это одно и то же.

=== Операции над указателями

[.notes]
--
Указатели можно складывать, вычитать, сравнивать. Но указатели должны быть одного типа. Т.е. не нужно
например складывать укатель типа *char* * и *int* *
--
[source, cpp]

----
int main() {
  int  arr[] = {1,2,3,4,5} ;    # <1>
  int* ptr = arr ;              # <2>

  ptr ++ ;                      # <3>
  int a = *(ptr + 4) ;          # <4>
  if(ptr != nullptr)            # <5>
    cout << a << ": " << *ptr;  # <6>
}
----
<1> Объявление массива *arr* из 5 элементов. В целом можно считать, что массив *arr* это указатель на первый элемент массива.
<2> Обявления указателя на массив типа *int* ;
<3> Увеличиваем указатель на 1. На самом деле мы смещаемся по адресам на размер равный *size_of(int)*, т.е. на 4 байта. Т.е
в данном случае указатель *ptr* стал указывать на элемент массива *arr[1]*.
<4> Объявляем переменную *а* типа *int* и присваиваем ей значение *аrr[4]*.
<5> Сравнение указателя с nullptr указателем.
<6> Вывод значения *а* и значения по адресу в указателе *ptr*. Вывод (5: 2)


Сложение указателей

.Сложение указателей
image::Lab2_4.png[]

[source, cpp]
----
int main() {
  int  arr[] = {1,2,3,4,5} ;    # <1>
  int* ptr = arr ;              # <2>

  ptr ++ ;                      # <3>
  int a = *(ptr + 3) ;          # <4>
}
----

[.notes]
--
<1> Объявление массива *arr* из 5 элементов. В целом можно считать, что массив *arr* это указатель на первый элемент массива.
<2> Обявления указателя на массив типа *int* ;
<3> Увеличиваем указатель на 1. На самом деле мы смещаемся по адресам на размер равный *size_of(int)*, т.е. на 4 байта. Т.е
в данном случае указатель *ptr* стал указывать на элемент массива *arr[1]*.
<4> Записываем в переменную а типа int данные, находящиеся по адресу, хранящиеся в указателе ptr, смещенном на 3.
--

== Регистр

* Существуют регистры общего назначения и специальные регистры. Регистры общего назначения расположены
внутри ядра микроконтроллера(сверхбыстрая память).

* Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для
хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных)
или данных, необходимых для работы самого процессора.

* Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления
процессором и периферийными устройствами.

* Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый
бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным
параметром микроконтроллера <<#10>>.

=== Регистры общего назначения

С точки зрения прикладного программиста, процессор располагает 16-ю 32-разрядными регистрами общего
назначения (РОН, GPR), из которых три на деле имеют специальные функции:

* Оперативные регистры
* Вспомогательные регистры
* Специальные регистры

=== Оперативные регистры

Регистры *R0-R3*, *R12* являются оперативными(sratch) регистрами. Любая функция может использовать эти
регистры по своему усмотрению и уничтожать содержимое этих регистров.

Если функции нужны значения этих регистров после вызова другой функции, она должна сохранить их на
стеке, а после вызова восстановить.

=== Вспомогательные регистры

Регистры от *R4-R11* являются вспомогательными. Любая функция должна сохранить их на входе, а при
выходе восстановить их значение.

=== Специальные регистры

* Регистр указателя на стек *R13/SP*, должен всегда указывать на последний элемент стека или ниже него.
* Регистр *R15/PC* есть программный счетчик.
* Регистр *R14/LR*, содержит адрес возврата функции.


=== Регистр специального назачения

[#Register]
.Схематичное изображение регистра
image::Lab2_5.png[800, 800]

[.notes]
--
* Название регистра
--
* Адрес регистра обозначается 32-битным шестнадцатеричным числом.
* Тип доступа к ячейкам регистра.
* Длина - количество ячеек в одном регистре. Мы будем работать с 32-битными регистрами.
* Поле - набор ячеек регистра, отвечающих за работу одной из функции микроконтроллера
* Значение поля - есть пространство всех возможных величин, которые может принимать поле

[.notes]
--
Значение поля зависит от длины поля. Т.е. если поле имеет длину 2, то существует 4 возможные
значения поля (0,1,2,3). Так же как у регистра, у полей и значений полей есть режим доступа (чтение,
записать, чтение и запись)
--

== Логические операции 

Дизъюнкция (логическое ИЛИ, операция OR) возвращает истину (1), если хотя бы один из операндов является истинным. Если оба операнда ложные, результат будет ложь (0). ||


Конъюнкция (логическое И, операция AND) возвращает истину (1), если оба операнда истинны. В противном случае результат — ложь (0). &&

.Простые логческие операции
image::Lab2_6.png[]

== Сброс бита

Сброс бита (или установка его в 0) выполняется с использованием побитовой операции И (AND) с маской. Если мы хотим сбросить конкретный бит, используем маску, в которой этот бит установлен в 0, а остальные биты — в 1.

[.source, cpp]
----
int x = 0b1011; // Двоичное значение 1011 (десятичное 11)
x &= ~(1 << 2); // Сбросим 2-й бит (нумерация с 0). Маска ~ (1 << 2) = 1111 1011
// Теперь x = 0b1001 (десятичное 9)
----

Пояснение:

*   1 << 2 сдвигает битовую единицу на 2 позиции влево, создавая маску 0000 0100.
*   Оператор ~ инвертирует эту маску: 1111 1011.
*   Операция x &= ~(1 << 2) применяет маску к переменной x с помощью побитового И, сбрасывая 2-й бит.


== Задания по лекции №2

[qanda]

. Если указатель типа Int указывает на адрес 1 и к этому указателю прибавит 1, то на какой адрес будет указывать указать и почему? А если указатель будет типа double:

Для int: 1 + (int) 1 = 1 + 4 * 1 = 5;

Для double: 1 + (double) 1 = 1 + 8 * 1 = 9.

. Eсли в ячейке по адресу 1 лежит число 10, в ячейке по адресу 2 лежит число 20, в ячейке по адресу 3 лежит число 30, в ячейке по адресу 4 лежит число 40 и если у нас указатель типа std::uint32_t указывает на адрес 1, то какое число будет в переменной b после разименовывания указателя?:

uint32_t весит 4 байта. 

10(В 10-ной системе исчисления) = 0х000A(В 16-ной системе исчисления);

20(10) = 0х0014(16);

30(10) = 0х001E(16);

40(10) = 0x0028(16);

b = 0xA141E28(16) = 169090600.

. std::uint32_t* ptr = reinterpret_cast<std::uin32_t>(1);
auto b = *ptr; //чему равно b?:

b хранит значение uint32_t по адресу 1. В размере 4 байта.


. std::uint16_t* ptr = reinterpret_cast<std::uin16_t>(1);
auto b = *ptr; //чему равно b?:

b хранит значение uint16_t по адресу 1. В размере 2 байта.



. auto b = "c";  // Какого типа b?:

Переменная b будет массивом символов (const char[]).



. auto b1 = 'c';  //Какого типа b1?:

Переменная b1 будет иметь символьный тип (char).

. char a = 'A';  //В какое число переведется символ А:
 
Символ А в кодировке ASCII имеет значение 65.

